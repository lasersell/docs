---
title: "Rate Limits and Tiers"
description: "Understand tier capacity, the limits object from hello_ok, and how to handle 429 responses."
---

## Pricing Tiers

LaserSell offers four tiers. Each tier determines your rate limits for both the REST API and the Exit Intelligence Stream.

| Tier | Name | Price |
|------|------|-------|
| 0 | Personal | Free |
| 1 | Professional | $49/mo |
| 2 | Advanced Exit Engine | $149/mo |
| â€” | Enterprise | Custom |

## Exit Intelligence Stream Limits by Tier

| Limit | Personal (Free) | Professional | Advanced | Enterprise |
|-------|-----------------|-------------|----------|------------|
| Wallets per session | 1 | 5 | 200 | Custom |
| Positions per wallet | 1 | 100 | 100 | Custom |
| Positions per session | 1 | 500 | 20,000 | Custom |
| Sessions per API key | 1 | 1 | 1 | Custom |
| High priority buffer (`hi_capacity`) | 256 | 256 | 256 | Custom |
| PnL flush interval (`pnl_flush_ms`) | 100 ms | 100 ms | 100 ms | Custom |
| Inactivity timeout | 45 min | None | None | None |
| Partner fees | No | No | Yes | Yes |

## REST API Rate Limits

The REST API (`/v1/sell`, `/v1/buy`) enforces a per key request limit using a sliding window.

| Tier | Requests per minute |
|------|-------------------|
| Personal (Free) | 60 |
| Professional | 60 |
| Advanced | 60 |
| Enterprise | Custom |

## Reading Your Limits on Connect

When you connect to the Exit Intelligence Stream, the `hello_ok` message includes a `limits` object that reflects your API key's tier:

```json
{
  "type": "hello_ok",
  "session_id": 42,
  "server_time_ms": 1706000000000,
  "limits": {
    "hi_capacity": 256,
    "pnl_flush_ms": 100,
    "max_positions_per_session": 500,
    "max_wallets_per_session": 5,
    "max_positions_per_wallet": 100,
    "max_sessions_per_api_key": 1
  }
}
```

## `LimitsMsg` Schema

| Field                        | Type     | Description                                                 |
|------------------------------|----------|-------------------------------------------------------------|
| `hi_capacity`                | `number` | Maximum high priority messages the server will buffer.       |
| `pnl_flush_ms`              | `number` | Interval in milliseconds between `pnl_update` flushes.      |
| `max_positions_per_session`  | `number` | Maximum positions tracked in a single session.               |
| `max_wallets_per_session`    | `number` | Maximum wallets that can be monitored in a single session.   |
| `max_positions_per_wallet`   | `number` | Maximum positions tracked per wallet.                        |
| `max_sessions_per_api_key`   | `number` | Maximum concurrent stream sessions per API key.              |

## Reading Limits in Code

<CodeGroup>
```typescript TypeScript
const session = await StreamSession.connect(client, configure);

// The hello_ok message is the first event
const event = await session.recv();
if (event?.type === "message" && event.message.type === "hello_ok") {
  const limits = event.message.limits;
  console.log("Max positions:", limits.max_positions_per_session);
  console.log("Max wallets:", limits.max_wallets_per_session);
  console.log("PnL interval:", limits.pnl_flush_ms, "ms");
}
```

```python Python
event = await session.recv()
if event and event.message.get("type") == "hello_ok":
    limits = event.message["limits"]
    print("Max positions:", limits["max_positions_per_session"])
    print("Max wallets:", limits["max_wallets_per_session"])
```

```rust Rust
if let Some(event) = session.recv().await {
    if let ServerMessage::HelloOk { limits, .. } = &event.message {
        println!("Max positions: {}", limits.max_positions_per_session);
        println!("Max wallets: {}", limits.max_wallets_per_session);
        println!("PnL interval: {} ms", limits.pnl_flush_ms);
    }
}
```

```go Go
event, err := session.Recv(ctx)
if err == nil {
    if msg, ok := event.Message.(stream.HelloOkServerMessage); ok {
        fmt.Println("Max positions:", msg.Limits.MaxPositionsPerSession)
        fmt.Println("Max wallets:", msg.Limits.MaxWalletsPerSession)
        fmt.Println("PnL interval:", msg.Limits.PnlFlushMs, "ms")
    }
}
```
</CodeGroup>

## Handling 429 Responses

When you exceed the REST API rate limit, the server responds with HTTP `429 Too Many Requests`. The SDKs automatically retry `429` responses using the built in retry policy. If you see persistent 429 errors:

1. **Check your request frequency.** Reduce the rate of API calls.
2. **Batch requests.** If building multiple transactions, space them out.
3. **Increase retry backoff.** Configure a longer backoff to give the server time to recover.

See [Error Handling](/api/exit-api/error-handling) for details on customizing the retry policy.

## Exit Intelligence Stream Capacity

If you exceed the Exit Intelligence Stream's capacity limits (e.g., too many positions or wallets), the server sends an `error` message:

```json
{
  "type": "error",
  "code": "capacity_exceeded",
  "message": "max_positions_per_session limit reached"
}
```

The stream connection remains open. Remove positions with `close_position` or reduce wallets with `update_wallets` to free capacity.

## Best Practices

- **Read limits on connect.** Use the `limits` object to validate your configuration before sending positions.
- **Monitor for capacity errors.** Log and alert on `error` messages with capacity related codes.
- **Use lane splitting.** For high position counts, use `connectLanes()` to prevent `pnl_update` messages from blocking time sensitive events.
- **Respect 429 responses.** Do not retry immediately; use exponential backoff.
